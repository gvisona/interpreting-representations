import numpy as np
import torch

def gaussian_reparameterization(mu, logvar):
    """Sample from the posterior distribution.

    Args:
        mu (Tensor): Mean of the latent Gaussian.
        logvar (Tensor): Logvar of the latent Gaussian.

    Returns:
        Tensor: random sample ~ N(mu, std)
    """

    std = torch.exp(0.5 * logvar)
    eps = torch.randn_like(std)
    return eps * std + mu

    def reparameterize_paired(self, mu1, mu2, log_var1, log_var2):
        """[summary]

        Args:
            mu1 (Tensor): mean generated by the encoding of image 1
            mu2 (Tensor): mean generated by the encoding of image 2
            log_var1 (Tensor): logarithm of the variances generated by the encoding of image 1
            log_var2 (Tensor): logarithm of the variances generated by the encoding of image 2
            method (str, optional): Averaging function for the common FOVs. Defaults to "GVAE".

        Returns:
            (Tensor, Tensor): The two sampled values from the reparametrization
        """
        common_fovs = get_common_FOVs(mu1, mu2, log_var1, log_var2)
        if self.averaging_method == "GVAE":
            avg_mu = 0.5 * (mu1[common_fovs] + mu2[common_fovs])
            avg_var = 0.5 * \
                (log_var1[common_fovs].exp() + log_var2[common_fovs].exp())
            avg_logvar = avg_var.log()
        elif self.averaging_method == "ML-VAE":
            avg_var = 1/(1/log_var1[common_fovs] + 1/log_var2[common_fovs])
            avg_mu = (mu1[common_fovs]/log_var1[common_fovs] +
                      mu2[common_fovs]/log_var2[common_fovs]) * avg_var
            avg_logvar = avg_var.log()
        else:
            raise ValueError("How did you end up here?")

        mu1[common_fovs] = avg_mu
        mu2[common_fovs] = avg_mu
        log_var1[common_fovs] = avg_logvar
        log_var2[common_fovs] = avg_logvar

        std1 = torch.exp(0.5*log_var1)
        eps1 = torch.randn_like(std1)
        z1 = eps1.mul(std1).add_(mu1)

        std2 = torch.exp(0.5*log_var2)
        eps2 = torch.randn_like(std2)
        z2 = eps2.mul(std2).add_(mu2)

        return z1, z2
        
def calc_output_size_transpose_convnet(input_shape, kernel_sizes, paddings=None, strides=None, dilations=None, output_paddings=None):
    """Calculate the output size of one or more Conv2dTranspose layers https://pytorch.org/docs/master/generated/torch.nn.ConvTranspose2d.html

    Arguments:
        input_shape {[type]} -- [description]
        kernel_sizes {[type]} -- [description]

    Keyword Arguments:
        paddings {[type]} -- [description] (default: {None})
        strides {[type]} -- [description] (default: {None})
        dilations {[type]} -- [description] (default: {None})
        output_paddings {[type]} -- [description] (default: {None})

    Raises:
        ValueError: [description]

    Returns:
        [type] -- [description]
    """
    if isinstance(input_shape, int):
        height = input_shape
        width = input_shape
    elif isinstance(input_shape, (tuple, list)):
        assert len(input_shape) == 2
        height, width = input_shape
    else:
        raise ValueError("Invalid input shape")

    if dilations is None:
        dilations = [1]*len(kernel_sizes)
    if strides is None:
        strides = [1]*len(kernel_sizes)
    if paddings is None:
        paddings = [0]*len(kernel_sizes)
    if output_paddings is None:
        output_paddings = [0]*len(kernel_sizes)

    for i in range(len(kernel_sizes)):
        p = paddings[i] if isinstance(paddings[i], int) else paddings[i][0]
        d = dilations[i] if isinstance(dilations[i], int) else dilations[i][0]
        k = kernel_sizes[i] if isinstance(
            kernel_sizes[i], int) else kernel_sizes[i][0]
        s = strides[i] if isinstance(strides[i], int) else strides[i][0]
        o = output_paddings[i] if isinstance(
            output_paddings[i], int) else output_paddings[i][0]

        height = (height-1)*s - 2*p + d*(k-1) + o + 1

        p = paddings[i] if isinstance(paddings[i], int) else paddings[i][1]
        d = dilations[i] if isinstance(dilations[i], int) else dilations[i][1]
        k = kernel_sizes[i] if isinstance(
            kernel_sizes[i], int) else kernel_sizes[i][1]
        s = strides[i] if isinstance(strides[i], int) else strides[i][1]
        o = output_paddings[i] if isinstance(
            output_paddings[i], int) else output_paddings[i][1]
        width = (width-1)*s - 2*p + d*(k-1) + o + 1
    return int(height), int(width)


def calc_output_size_convnet(input_shape, kernel_sizes, paddings=None, strides=None, dilations=None):
    """Calculate the output size of one or more Conv2d layers  https://pytorch.org/docs/master/generated/torch.nn.Conv2d.html

    Arguments:
        input_shape {[type]} -- [description]
        kernel_sizes {[type]} -- [description]

    Keyword Arguments:
        paddings {[type]} -- [description] (default: {None})
        strides {[type]} -- [description] (default: {None})
        dilations {[type]} -- [description] (default: {None})

    Raises:
        ValueError: [description]

    Returns:
        [type] -- [description]
    """
    if isinstance(input_shape, int):
        height = input_shape
        width = input_shape
    elif isinstance(input_shape, (tuple, list)):
        assert len(input_shape) == 2
        height, width = input_shape
    else:
        raise ValueError("Invalid input shape")

    if dilations is None:
        dilations = [1]*len(kernel_sizes)
    if strides is None:
        strides = [1]*len(kernel_sizes)
    if paddings is None:
        paddings = [0]*len(kernel_sizes)

    for i in range(len(kernel_sizes)):
        p = paddings[i] if isinstance(paddings[i], int) else paddings[i][0]
        d = dilations[i] if isinstance(dilations[i], int) else dilations[i][0]
        k = kernel_sizes[i] if isinstance(
            kernel_sizes[i], int) else kernel_sizes[i][0]
        s = strides[i] if isinstance(strides[i], int) else strides[i][0]
        height = (height + 2*p - d * (k - 1) - 1)/s + 1

        p = paddings[i] if isinstance(paddings[i], int) else paddings[i][1]
        d = dilations[i] if isinstance(dilations[i], int) else dilations[i][1]
        k = kernel_sizes[i] if isinstance(
            kernel_sizes[i], int) else kernel_sizes[i][1]
        s = strides[i] if isinstance(strides[i], int) else strides[i][1]
        width = (width + 2*p - d * (k - 1) - 1)/s + 1
    return int(height), int(width)
